---
title: "[Python] 데이터 사이언스 스쿨 - 4.7 피봇테이블과 그룹분석"
excerpt: "4.7 피봇테이블과 그룹분석"
categories: 
  - dss
tags: 
    - Python
    - dss
    - pandas
# toc: TRUE
# toc_sticky: TRUE
use_math: TRUE
---

[데이터 사이언스 스쿨](https://datascienceschool.net/intro.html) 자료를 토대로 공부한 내용입니다.

실습과정에서 필요에 따라 내용의 누락 및 추가, 수정사항이 있습니다.

---


# 4.7 피봇테이블과 그룹분석

## 미리보는 요약 정리

**pivot(행으로 사용할 열이름, 열로 사용할 열이름, 값)**

- 행/열별 중복이 있으면 오류가 생기고 단순히 값만 추출
- 엑셀의 피봇 형태에서 값만 기존 값인 형태

**groupby(행으로 사용할 열이름).그룹별 연산 함수( )**

- 행/열별 중복에 따른 그룹별 연산값 추출
- 엑셀의 피봇 형태와 가까우나 열 인덱스를 직접 지정할 수 없음
- unstack()을 이용해서 엑셀의 피봇 형태 만들 수 있음

**pivot_table(값, 행으로 사용할 열이름, 열로 사용할 열이름, 추가옵션)**

- 행/열별 중복이 없으면 pivot 결과 출력 가능
- 열로 사용할 열이름을 지정하지 않으면 groupby 형태 출력 가능
- 엑셀의 피봇 형태

## PIVOT


```python
import numpy as np
import pandas as pd
```


```python
data = {
    "도시": ["서울", "서울", "서울", "부산", "부산", "부산", "인천", "인천"],
    "연도": ["2015", "2010", "2005", "2015", "2010", "2005", "2015", "2010"],
    "인구": [9904312, 9631482, 9762546, 3448737, 3393191, 3512547, 2890451, 263203],
    "지역": ["수도권", "수도권", "수도권", "경상권", "경상권", "경상권", "수도권", "수도권"]
}
columns = ["도시", "연도", "인구", "지역"]
df1 = pd.DataFrame(data, columns=columns)
df1
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>도시</th>
      <th>연도</th>
      <th>인구</th>
      <th>지역</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>서울</td>
      <td>2015</td>
      <td>9904312</td>
      <td>수도권</td>
    </tr>
    <tr>
      <th>1</th>
      <td>서울</td>
      <td>2010</td>
      <td>9631482</td>
      <td>수도권</td>
    </tr>
    <tr>
      <th>2</th>
      <td>서울</td>
      <td>2005</td>
      <td>9762546</td>
      <td>수도권</td>
    </tr>
    <tr>
      <th>3</th>
      <td>부산</td>
      <td>2015</td>
      <td>3448737</td>
      <td>경상권</td>
    </tr>
    <tr>
      <th>4</th>
      <td>부산</td>
      <td>2010</td>
      <td>3393191</td>
      <td>경상권</td>
    </tr>
    <tr>
      <th>5</th>
      <td>부산</td>
      <td>2005</td>
      <td>3512547</td>
      <td>경상권</td>
    </tr>
    <tr>
      <th>6</th>
      <td>인천</td>
      <td>2015</td>
      <td>2890451</td>
      <td>수도권</td>
    </tr>
    <tr>
      <th>7</th>
      <td>인천</td>
      <td>2010</td>
      <td>263203</td>
      <td>수도권</td>
    </tr>
  </tbody>
</table>
</div>




```python
# pivot(행, 열, 값 ) - 모두 열 인덱스를 넣어야함
df1.pivot("도시","연도","인구")
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>연도</th>
      <th>2005</th>
      <th>2010</th>
      <th>2015</th>
    </tr>
    <tr>
      <th>도시</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>부산</th>
      <td>3512547.0</td>
      <td>3393191.0</td>
      <td>3448737.0</td>
    </tr>
    <tr>
      <th>서울</th>
      <td>9762546.0</td>
      <td>9631482.0</td>
      <td>9904312.0</td>
    </tr>
    <tr>
      <th>인천</th>
      <td>NaN</td>
      <td>263203.0</td>
      <td>2890451.0</td>
    </tr>
  </tbody>
</table>
</div>



- `pivot()`을 사용하면 지정한 행, 열의 조합에 따른 값을 확인 할 수 있다.


- 위 예시에서 인천은 2005년 데이터가 없기 때문에 NaN 값으로 나타난다.


```python
df1.set_index(["도시", "연도"])[["인구"]].unstack(1)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th colspan="3" halign="left">인구</th>
    </tr>
    <tr>
      <th>연도</th>
      <th>2005</th>
      <th>2010</th>
      <th>2015</th>
    </tr>
    <tr>
      <th>도시</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>부산</th>
      <td>3512547.0</td>
      <td>3393191.0</td>
      <td>3448737.0</td>
    </tr>
    <tr>
      <th>서울</th>
      <td>9762546.0</td>
      <td>9631482.0</td>
      <td>9904312.0</td>
    </tr>
    <tr>
      <th>인천</th>
      <td>NaN</td>
      <td>263203.0</td>
      <td>2890451.0</td>
    </tr>
  </tbody>
</table>
</div>



- `set_index()`와 `unstack()`으로 같은 결과를 출력 가능하다.


```python
# 다중 인덱스 피봇 테이블
df1.pivot(["지역", "도시"], "연도", "인구")
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>연도</th>
      <th>2005</th>
      <th>2010</th>
      <th>2015</th>
    </tr>
    <tr>
      <th>지역</th>
      <th>도시</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>경상권</th>
      <th>부산</th>
      <td>3512547.0</td>
      <td>3393191.0</td>
      <td>3448737.0</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">수도권</th>
      <th>서울</th>
      <td>9762546.0</td>
      <td>9631482.0</td>
      <td>9904312.0</td>
    </tr>
    <tr>
      <th>인천</th>
      <td>NaN</td>
      <td>263203.0</td>
      <td>2890451.0</td>
    </tr>
  </tbody>
</table>
</div>



- 다중 인덱스인 경우도 `pivot()`을 사용 가능하다.


```python
# set_index와 unstack으로 같은 결과 출력
df1.set_index(["지역","도시", "연도"])[["인구"]].unstack(2)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th colspan="3" halign="left">인구</th>
    </tr>
    <tr>
      <th></th>
      <th>연도</th>
      <th>2005</th>
      <th>2010</th>
      <th>2015</th>
    </tr>
    <tr>
      <th>지역</th>
      <th>도시</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>경상권</th>
      <th>부산</th>
      <td>3512547.0</td>
      <td>3393191.0</td>
      <td>3448737.0</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">수도권</th>
      <th>서울</th>
      <td>9762546.0</td>
      <td>9631482.0</td>
      <td>9904312.0</td>
    </tr>
    <tr>
      <th>인천</th>
      <td>NaN</td>
      <td>263203.0</td>
      <td>2890451.0</td>
    </tr>
  </tbody>
</table>
</div>



- 다중 인덱스도 마찬가지로 `set_index()`와 `unstack()`으로 같은 결과를 출력 가능하다.


```python
try:
    df1.pivot("지역", "연도", "인구")
except ValueError as e:
    print("ValueError:", e)
```

    ValueError: Index contains duplicate entries, cannot reshape
    

- `pivot()` 함수를 사용할 때 주의할 점은 행과 열의 조합에 따른 값은 반드시 1개가 존재하여야한다.


- 그렇지 않은 경우 에러가 발생한다.

## GROUP BY


```python
np.random.seed(0)
df2 = pd.DataFrame({
    'key1': ['A', 'A', 'B', 'B', 'A'],
    'key2': ['one', 'two', 'one', 'two', 'one'],
    'data1': [1, 2, 3, 4, 5],
    'data2': [10, 20, 30, 40, 50]
})
df2
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key1</th>
      <th>key2</th>
      <th>data1</th>
      <th>data2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>A</td>
      <td>one</td>
      <td>1</td>
      <td>10</td>
    </tr>
    <tr>
      <th>1</th>
      <td>A</td>
      <td>two</td>
      <td>2</td>
      <td>20</td>
    </tr>
    <tr>
      <th>2</th>
      <td>B</td>
      <td>one</td>
      <td>3</td>
      <td>30</td>
    </tr>
    <tr>
      <th>3</th>
      <td>B</td>
      <td>two</td>
      <td>4</td>
      <td>40</td>
    </tr>
    <tr>
      <th>4</th>
      <td>A</td>
      <td>one</td>
      <td>5</td>
      <td>50</td>
    </tr>
  </tbody>
</table>
</div>




```python
# key1에 따른 그룹 데이터
g = df2.groupby(df2.key1)
g
```




    <pandas.core.groupby.generic.DataFrameGroupBy object at 0x000002BC4BFB8220>




```python
# 그룹별 인덱스 위치
g.groups
```




    {'A': [0, 1, 4], 'B': [2, 3]}



- `groupby()` 함수를 사용하면 특정 열에 따른 그룹 데이터를 생성 가능하다.


- `groupby()`로 생성된 그룹 데이터 객체에 `groups` 속성을 사용하면 그룹별 인덱스 위치를 확인 할 수 있다.


- 그룹 데이터 객체를 이용하여서 여러 그룹별 연산을 실행가능하다.

**그룹별 연산 예시 - 내장함수**

- size, count: 그룹 데이터의 갯수


- mean, median, min, max: 그룹 데이터의 평균, 중앙값, 최소, 최대


- sum, prod, std, var, quantile : 그룹 데이터의 합계, 곱, 표준편차, 분산, 사분위수


- first, last: 그룹 데이터 중 가장 첫번째 데이터와 가장 나중 데이터


```python
# 자동으로 숫자형만 출력
g.sum()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>data1</th>
      <th>data2</th>
    </tr>
    <tr>
      <th>key1</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>A</th>
      <td>8</td>
      <td>80</td>
    </tr>
    <tr>
      <th>B</th>
      <td>7</td>
      <td>70</td>
    </tr>
  </tbody>
</table>
</div>



- 앞서 생성한 그룹 데이터를 이용하여서 key1의 값별로 data1, data2의 합계를 확인하였다.


```python
# 하나의 열만 보고 싶은 경우 - 3가지 모두 같은 결과
df2.data1.groupby(df2.key1).sum()

df2.groupby(df2.key1)["data1"].sum()

df2.groupby(df2.key1).sum()["data1"]
```




    key1
    A    8
    B    7
    Name: data1, dtype: int64



- 만약 key1의 값별로 하나의 열만 합계를 보고 싶다면 위 3가지 방법을 적용한다.

## 연습문제 4.7.1

key1의 값을 기준으로 data1의 값을 분류하여 합계를 구한 결과를 시리즈가 아닌 데이터프레임으로 구한다.


```python
# 그룹별 합계 데이터
df2.groupby(df2["key1"]).sum()[["data1"]]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>data1</th>
    </tr>
    <tr>
      <th>key1</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>A</th>
      <td>8</td>
    </tr>
    <tr>
      <th>B</th>
      <td>7</td>
    </tr>
  </tbody>
</table>
</div>



**복합키 사용**


```python
df2.groupby([df2.key1, df2.key2]).sum()[["data1"]]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>data1</th>
    </tr>
    <tr>
      <th>key1</th>
      <th>key2</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">A</th>
      <th>one</th>
      <td>6</td>
    </tr>
    <tr>
      <th>two</th>
      <td>2</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">B</th>
      <th>one</th>
      <td>3</td>
    </tr>
    <tr>
      <th>two</th>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>



- 여러 열을 지정하여서 그룹별 연산을 수행할 수 있다.


```python
# unstack을 이용하여 피봇테이블 형태1
df2.groupby([df2.key1, df2.key2]).sum()[["data1"]].unstack("key2")
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th colspan="2" halign="left">data1</th>
    </tr>
    <tr>
      <th>key2</th>
      <th>one</th>
      <th>two</th>
    </tr>
    <tr>
      <th>key1</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>A</th>
      <td>6</td>
      <td>2</td>
    </tr>
    <tr>
      <th>B</th>
      <td>3</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>




```python
# unstack을 이용하여 피봇테이블 형태2
df1["인구"].groupby([df1["지역"], df1["연도"]]).sum().unstack("연도")
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>연도</th>
      <th>2005</th>
      <th>2010</th>
      <th>2015</th>
    </tr>
    <tr>
      <th>지역</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>경상권</th>
      <td>3512547</td>
      <td>3393191</td>
      <td>3448737</td>
    </tr>
    <tr>
      <th>수도권</th>
      <td>9762546</td>
      <td>9894685</td>
      <td>12794763</td>
    </tr>
  </tbody>
</table>
</div>



- 여러 열을 지정해서 그룹별 연산 수행 후 `unstack()`을 사용하면 뒤에 나올 `pivot_table()`형태로 만들 수 있다.


```python
# pivot을 이용해서 같은 결과 출력
temp = df2.groupby([df2.key1, df2.key2]).sum()[["data1"]]
temp = temp.reset_index()
temp.pivot("key1","key2","data1")
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>key2</th>
      <th>one</th>
      <th>two</th>
    </tr>
    <tr>
      <th>key1</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>A</th>
      <td>6</td>
      <td>2</td>
    </tr>
    <tr>
      <th>B</th>
      <td>3</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>



- 위 예시는 `pivot()`을 이용해서 `groupby()` 결과를 출력해보았다.


- 다만 `pivot()`을 사용하려고 사전 작업으로 `groupby()`를 사용하였고 굳이 이렇게 할 필요가 없어 보인다.


```python
# iris 데이터
import seaborn as sns
iris = sns.load_dataset("iris")
iris.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>sepal_length</th>
      <th>sepal_width</th>
      <th>petal_length</th>
      <th>petal_width</th>
      <th>species</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>5.1</td>
      <td>3.5</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>setosa</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4.9</td>
      <td>3.0</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>setosa</td>
    </tr>
    <tr>
      <th>2</th>
      <td>4.7</td>
      <td>3.2</td>
      <td>1.3</td>
      <td>0.2</td>
      <td>setosa</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4.6</td>
      <td>3.1</td>
      <td>1.5</td>
      <td>0.2</td>
      <td>setosa</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5.0</td>
      <td>3.6</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>setosa</td>
    </tr>
  </tbody>
</table>
</div>



- 이번엔 iris 데이터를 이용해서 여러 그룹별 연산을 시행해보자.

**그룹별 연산 예시**

- agg

    - 만약 원하는 그룹연산이 없는 경우 함수를 만들고 이 함수를 agg에 전달한다.

    - 또는 여러가지 그룹연산을 동시에 하고 싶은 경우 함수 이름 문자열의 리스트를 전달한다.


- describe

    - 하나의 그룹 대표값이 아니라 여러개의 값을 데이터프레임으로 구한다.


- apply

    - describe 처럼 하나의 대표값이 아닌 데이터프레임을 출력하지만 원하는 그룹연산이 없는 경우에 사용한다.


- transform

    - 그룹에 대한 대표값을 만드는 것이 아니라 그룹별 계산을 통해 데이터 자체를 변형한다.


```python
# agg
def peak_to_peak_ratio(x):
    return x.max() / x.min()

iris.groupby(iris.species).agg(peak_to_peak_ratio)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>sepal_length</th>
      <th>sepal_width</th>
      <th>petal_length</th>
      <th>petal_width</th>
    </tr>
    <tr>
      <th>species</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>setosa</th>
      <td>1.348837</td>
      <td>1.913043</td>
      <td>1.900000</td>
      <td>6.000000</td>
    </tr>
    <tr>
      <th>versicolor</th>
      <td>1.428571</td>
      <td>1.700000</td>
      <td>1.700000</td>
      <td>1.800000</td>
    </tr>
    <tr>
      <th>virginica</th>
      <td>1.612245</td>
      <td>1.727273</td>
      <td>1.533333</td>
      <td>1.785714</td>
    </tr>
  </tbody>
</table>
</div>



- `agg()` 함수에 최대값/최소값을 산출하는 `peak_to_peak_ratio()`함수를 입력하였다.


- 붓꽃 종별로 `peak_to_peak_ratio()`의 결과 값이 잘 나타난다.


- `agg()`에는 하나의 값을 산출하는 함수를 넣어주어야 한다.


```python
# describe
iris.groupby(iris.species).describe().T
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>species</th>
      <th>setosa</th>
      <th>versicolor</th>
      <th>virginica</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="8" valign="top">sepal_length</th>
      <th>count</th>
      <td>50.000000</td>
      <td>50.000000</td>
      <td>50.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>5.006000</td>
      <td>5.936000</td>
      <td>6.588000</td>
    </tr>
    <tr>
      <th>std</th>
      <td>0.352490</td>
      <td>0.516171</td>
      <td>0.635880</td>
    </tr>
    <tr>
      <th>min</th>
      <td>4.300000</td>
      <td>4.900000</td>
      <td>4.900000</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>4.800000</td>
      <td>5.600000</td>
      <td>6.225000</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>5.000000</td>
      <td>5.900000</td>
      <td>6.500000</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>5.200000</td>
      <td>6.300000</td>
      <td>6.900000</td>
    </tr>
    <tr>
      <th>max</th>
      <td>5.800000</td>
      <td>7.000000</td>
      <td>7.900000</td>
    </tr>
    <tr>
      <th rowspan="8" valign="top">sepal_width</th>
      <th>count</th>
      <td>50.000000</td>
      <td>50.000000</td>
      <td>50.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>3.428000</td>
      <td>2.770000</td>
      <td>2.974000</td>
    </tr>
    <tr>
      <th>std</th>
      <td>0.379064</td>
      <td>0.313798</td>
      <td>0.322497</td>
    </tr>
    <tr>
      <th>min</th>
      <td>2.300000</td>
      <td>2.000000</td>
      <td>2.200000</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>3.200000</td>
      <td>2.525000</td>
      <td>2.800000</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>3.400000</td>
      <td>2.800000</td>
      <td>3.000000</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>3.675000</td>
      <td>3.000000</td>
      <td>3.175000</td>
    </tr>
    <tr>
      <th>max</th>
      <td>4.400000</td>
      <td>3.400000</td>
      <td>3.800000</td>
    </tr>
    <tr>
      <th rowspan="8" valign="top">petal_length</th>
      <th>count</th>
      <td>50.000000</td>
      <td>50.000000</td>
      <td>50.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>1.462000</td>
      <td>4.260000</td>
      <td>5.552000</td>
    </tr>
    <tr>
      <th>std</th>
      <td>0.173664</td>
      <td>0.469911</td>
      <td>0.551895</td>
    </tr>
    <tr>
      <th>min</th>
      <td>1.000000</td>
      <td>3.000000</td>
      <td>4.500000</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>1.400000</td>
      <td>4.000000</td>
      <td>5.100000</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>1.500000</td>
      <td>4.350000</td>
      <td>5.550000</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>1.575000</td>
      <td>4.600000</td>
      <td>5.875000</td>
    </tr>
    <tr>
      <th>max</th>
      <td>1.900000</td>
      <td>5.100000</td>
      <td>6.900000</td>
    </tr>
    <tr>
      <th rowspan="8" valign="top">petal_width</th>
      <th>count</th>
      <td>50.000000</td>
      <td>50.000000</td>
      <td>50.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>0.246000</td>
      <td>1.326000</td>
      <td>2.026000</td>
    </tr>
    <tr>
      <th>std</th>
      <td>0.105386</td>
      <td>0.197753</td>
      <td>0.274650</td>
    </tr>
    <tr>
      <th>min</th>
      <td>0.100000</td>
      <td>1.000000</td>
      <td>1.400000</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>0.200000</td>
      <td>1.200000</td>
      <td>1.800000</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>0.200000</td>
      <td>1.300000</td>
      <td>2.000000</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>0.300000</td>
      <td>1.500000</td>
      <td>2.300000</td>
    </tr>
    <tr>
      <th>max</th>
      <td>0.600000</td>
      <td>1.800000</td>
      <td>2.500000</td>
    </tr>
  </tbody>
</table>
</div>



- `describe()`는 기술 통계량 산출해주는 함수로 꼭 `groupby()`가 아니어도 사용 가능하다.


```python
# apply
# petal_length가 가장 큰 3개 행 출력 
def top3_petal_length(df):
    top3_pl = df.sort_values(by="petal_length", ascending=False)[:3]
    top3_pl = top3_pl[["sepal_length", "sepal_width", "petal_length", "petal_width"]]
    
    return top3_pl

iris.groupby(iris.species).apply(top3_petal_length)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>sepal_length</th>
      <th>sepal_width</th>
      <th>petal_length</th>
      <th>petal_width</th>
    </tr>
    <tr>
      <th>species</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="3" valign="top">setosa</th>
      <th>24</th>
      <td>4.8</td>
      <td>3.4</td>
      <td>1.9</td>
      <td>0.2</td>
    </tr>
    <tr>
      <th>44</th>
      <td>5.1</td>
      <td>3.8</td>
      <td>1.9</td>
      <td>0.4</td>
    </tr>
    <tr>
      <th>23</th>
      <td>5.1</td>
      <td>3.3</td>
      <td>1.7</td>
      <td>0.5</td>
    </tr>
    <tr>
      <th rowspan="3" valign="top">versicolor</th>
      <th>83</th>
      <td>6.0</td>
      <td>2.7</td>
      <td>5.1</td>
      <td>1.6</td>
    </tr>
    <tr>
      <th>77</th>
      <td>6.7</td>
      <td>3.0</td>
      <td>5.0</td>
      <td>1.7</td>
    </tr>
    <tr>
      <th>72</th>
      <td>6.3</td>
      <td>2.5</td>
      <td>4.9</td>
      <td>1.5</td>
    </tr>
    <tr>
      <th rowspan="3" valign="top">virginica</th>
      <th>118</th>
      <td>7.7</td>
      <td>2.6</td>
      <td>6.9</td>
      <td>2.3</td>
    </tr>
    <tr>
      <th>117</th>
      <td>7.7</td>
      <td>3.8</td>
      <td>6.7</td>
      <td>2.2</td>
    </tr>
    <tr>
      <th>122</th>
      <td>7.7</td>
      <td>2.8</td>
      <td>6.7</td>
      <td>2.0</td>
    </tr>
  </tbody>
</table>
</div>



- `apply()`는 `agg()`와 비슷하지만 하나의 값이 아닌 여러개의 값을 출력한다.


- 위 예시에선 각 붓꽃 종별로 petal_length가 가장 큰 3개의 행을 출력하였다.


```python
# transform
# 붓꽃 종별 petal_length의 소/중/대 구분
def q3cut(s):
    return pd.qcut(s, 3, labels=["소", "중", "대"]).astype(str)

iris["petal_length_class"] = iris.groupby(iris.species)["petal_length"].transform(q3cut)
iris.tail(10)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>sepal_length</th>
      <th>sepal_width</th>
      <th>petal_length</th>
      <th>petal_width</th>
      <th>species</th>
      <th>petal_length_class</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>140</th>
      <td>6.7</td>
      <td>3.1</td>
      <td>5.6</td>
      <td>2.4</td>
      <td>virginica</td>
      <td>중</td>
    </tr>
    <tr>
      <th>141</th>
      <td>6.9</td>
      <td>3.1</td>
      <td>5.1</td>
      <td>2.3</td>
      <td>virginica</td>
      <td>소</td>
    </tr>
    <tr>
      <th>142</th>
      <td>5.8</td>
      <td>2.7</td>
      <td>5.1</td>
      <td>1.9</td>
      <td>virginica</td>
      <td>소</td>
    </tr>
    <tr>
      <th>143</th>
      <td>6.8</td>
      <td>3.2</td>
      <td>5.9</td>
      <td>2.3</td>
      <td>virginica</td>
      <td>대</td>
    </tr>
    <tr>
      <th>144</th>
      <td>6.7</td>
      <td>3.3</td>
      <td>5.7</td>
      <td>2.5</td>
      <td>virginica</td>
      <td>중</td>
    </tr>
    <tr>
      <th>145</th>
      <td>6.7</td>
      <td>3.0</td>
      <td>5.2</td>
      <td>2.3</td>
      <td>virginica</td>
      <td>소</td>
    </tr>
    <tr>
      <th>146</th>
      <td>6.3</td>
      <td>2.5</td>
      <td>5.0</td>
      <td>1.9</td>
      <td>virginica</td>
      <td>소</td>
    </tr>
    <tr>
      <th>147</th>
      <td>6.5</td>
      <td>3.0</td>
      <td>5.2</td>
      <td>2.0</td>
      <td>virginica</td>
      <td>소</td>
    </tr>
    <tr>
      <th>148</th>
      <td>6.2</td>
      <td>3.4</td>
      <td>5.4</td>
      <td>2.3</td>
      <td>virginica</td>
      <td>중</td>
    </tr>
    <tr>
      <th>149</th>
      <td>5.9</td>
      <td>3.0</td>
      <td>5.1</td>
      <td>1.8</td>
      <td>virginica</td>
      <td>소</td>
    </tr>
  </tbody>
</table>
</div>



- `transform()`은 그룹별 대표값을 만드는 것이 아니라 그룹별 계산을 통해 데이터프레임 자체를 변화시킨다. 


- 위 예시에선 붓꽃 종별로 petal_length를 소/중/대로 구분하였다.


- 작업 순서는 iris 그룹 데이터 생성 후, 그룹 데이터에서 petal_length를 선택, 마지막으로 `transform()`이다.

## 연습문제 4.7.2

붓꽃(iris) 데이터에서 붓꽃 종(species)별로 꽃잎길이(sepal_length), 꽃잎폭(sepal_width) 등의 평균을 구하라. 

만약 붓꽃 종(species)이 표시되지 않았을 때 이 수치들을 이용하여 붓꽃 종을 찾아낼 수 있을지 생각하라.


```python
# 붓꽃 종별 평균
iris.groupby(iris.species).mean()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>sepal_length</th>
      <th>sepal_width</th>
      <th>petal_length</th>
      <th>petal_width</th>
    </tr>
    <tr>
      <th>species</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>setosa</th>
      <td>5.006</td>
      <td>3.428</td>
      <td>1.462</td>
      <td>0.246</td>
    </tr>
    <tr>
      <th>versicolor</th>
      <td>5.936</td>
      <td>2.770</td>
      <td>4.260</td>
      <td>1.326</td>
    </tr>
    <tr>
      <th>virginica</th>
      <td>6.588</td>
      <td>2.974</td>
      <td>5.552</td>
      <td>2.026</td>
    </tr>
  </tbody>
</table>
</div>




```python
# 붓꽃 종별 평균을 중복으로 넣음
temp = iris.groupby(iris.species).transform("mean")
temp.columns = ["mean_sl", "mean_sw", "mean_pl", "mean_pw"]

temp2 = pd.concat([iris,temp], axis=1)
temp2
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>sepal_length</th>
      <th>sepal_width</th>
      <th>petal_length</th>
      <th>petal_width</th>
      <th>species</th>
      <th>petal_length_class</th>
      <th>mean_sl</th>
      <th>mean_sw</th>
      <th>mean_pl</th>
      <th>mean_pw</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>5.1</td>
      <td>3.5</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>setosa</td>
      <td>소</td>
      <td>5.006</td>
      <td>3.428</td>
      <td>1.462</td>
      <td>0.246</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4.9</td>
      <td>3.0</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>setosa</td>
      <td>소</td>
      <td>5.006</td>
      <td>3.428</td>
      <td>1.462</td>
      <td>0.246</td>
    </tr>
    <tr>
      <th>2</th>
      <td>4.7</td>
      <td>3.2</td>
      <td>1.3</td>
      <td>0.2</td>
      <td>setosa</td>
      <td>소</td>
      <td>5.006</td>
      <td>3.428</td>
      <td>1.462</td>
      <td>0.246</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4.6</td>
      <td>3.1</td>
      <td>1.5</td>
      <td>0.2</td>
      <td>setosa</td>
      <td>중</td>
      <td>5.006</td>
      <td>3.428</td>
      <td>1.462</td>
      <td>0.246</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5.0</td>
      <td>3.6</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>setosa</td>
      <td>소</td>
      <td>5.006</td>
      <td>3.428</td>
      <td>1.462</td>
      <td>0.246</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>145</th>
      <td>6.7</td>
      <td>3.0</td>
      <td>5.2</td>
      <td>2.3</td>
      <td>virginica</td>
      <td>소</td>
      <td>6.588</td>
      <td>2.974</td>
      <td>5.552</td>
      <td>2.026</td>
    </tr>
    <tr>
      <th>146</th>
      <td>6.3</td>
      <td>2.5</td>
      <td>5.0</td>
      <td>1.9</td>
      <td>virginica</td>
      <td>소</td>
      <td>6.588</td>
      <td>2.974</td>
      <td>5.552</td>
      <td>2.026</td>
    </tr>
    <tr>
      <th>147</th>
      <td>6.5</td>
      <td>3.0</td>
      <td>5.2</td>
      <td>2.0</td>
      <td>virginica</td>
      <td>소</td>
      <td>6.588</td>
      <td>2.974</td>
      <td>5.552</td>
      <td>2.026</td>
    </tr>
    <tr>
      <th>148</th>
      <td>6.2</td>
      <td>3.4</td>
      <td>5.4</td>
      <td>2.3</td>
      <td>virginica</td>
      <td>중</td>
      <td>6.588</td>
      <td>2.974</td>
      <td>5.552</td>
      <td>2.026</td>
    </tr>
    <tr>
      <th>149</th>
      <td>5.9</td>
      <td>3.0</td>
      <td>5.1</td>
      <td>1.8</td>
      <td>virginica</td>
      <td>소</td>
      <td>6.588</td>
      <td>2.974</td>
      <td>5.552</td>
      <td>2.026</td>
    </tr>
  </tbody>
</table>
<p>150 rows × 10 columns</p>
</div>




```python
# 붓꽃 종별 평균만 알때 종류 변수 추가
temp2["species2"] = temp2.apply(lambda x: "setosa" if round(x.mean_sl,3) == 5.006
                                 else "versicolor" if round(x.mean_sl,3) == 5.936
                                 else "vriginica", axis=1)
temp2
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>sepal_length</th>
      <th>sepal_width</th>
      <th>petal_length</th>
      <th>petal_width</th>
      <th>species</th>
      <th>petal_length_class</th>
      <th>mean_sl</th>
      <th>mean_sw</th>
      <th>mean_pl</th>
      <th>mean_pw</th>
      <th>species2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>5.1</td>
      <td>3.5</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>setosa</td>
      <td>소</td>
      <td>5.006</td>
      <td>3.428</td>
      <td>1.462</td>
      <td>0.246</td>
      <td>setosa</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4.9</td>
      <td>3.0</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>setosa</td>
      <td>소</td>
      <td>5.006</td>
      <td>3.428</td>
      <td>1.462</td>
      <td>0.246</td>
      <td>setosa</td>
    </tr>
    <tr>
      <th>2</th>
      <td>4.7</td>
      <td>3.2</td>
      <td>1.3</td>
      <td>0.2</td>
      <td>setosa</td>
      <td>소</td>
      <td>5.006</td>
      <td>3.428</td>
      <td>1.462</td>
      <td>0.246</td>
      <td>setosa</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4.6</td>
      <td>3.1</td>
      <td>1.5</td>
      <td>0.2</td>
      <td>setosa</td>
      <td>중</td>
      <td>5.006</td>
      <td>3.428</td>
      <td>1.462</td>
      <td>0.246</td>
      <td>setosa</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5.0</td>
      <td>3.6</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>setosa</td>
      <td>소</td>
      <td>5.006</td>
      <td>3.428</td>
      <td>1.462</td>
      <td>0.246</td>
      <td>setosa</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>145</th>
      <td>6.7</td>
      <td>3.0</td>
      <td>5.2</td>
      <td>2.3</td>
      <td>virginica</td>
      <td>소</td>
      <td>6.588</td>
      <td>2.974</td>
      <td>5.552</td>
      <td>2.026</td>
      <td>vriginica</td>
    </tr>
    <tr>
      <th>146</th>
      <td>6.3</td>
      <td>2.5</td>
      <td>5.0</td>
      <td>1.9</td>
      <td>virginica</td>
      <td>소</td>
      <td>6.588</td>
      <td>2.974</td>
      <td>5.552</td>
      <td>2.026</td>
      <td>vriginica</td>
    </tr>
    <tr>
      <th>147</th>
      <td>6.5</td>
      <td>3.0</td>
      <td>5.2</td>
      <td>2.0</td>
      <td>virginica</td>
      <td>소</td>
      <td>6.588</td>
      <td>2.974</td>
      <td>5.552</td>
      <td>2.026</td>
      <td>vriginica</td>
    </tr>
    <tr>
      <th>148</th>
      <td>6.2</td>
      <td>3.4</td>
      <td>5.4</td>
      <td>2.3</td>
      <td>virginica</td>
      <td>중</td>
      <td>6.588</td>
      <td>2.974</td>
      <td>5.552</td>
      <td>2.026</td>
      <td>vriginica</td>
    </tr>
    <tr>
      <th>149</th>
      <td>5.9</td>
      <td>3.0</td>
      <td>5.1</td>
      <td>1.8</td>
      <td>virginica</td>
      <td>소</td>
      <td>6.588</td>
      <td>2.974</td>
      <td>5.552</td>
      <td>2.026</td>
      <td>vriginica</td>
    </tr>
  </tbody>
</table>
<p>150 rows × 11 columns</p>
</div>



- 나는 이 연습문제를 풀 때 붓꽃 종별 평균을 원래 데이터 프레임에 중복으로 넣었다.


- 그 후 평균 수치를 알고 있으므로 특정 값이면 species2를 만들었다.


- 풀이는 여러 방법이 가능하고, 나처럼 종별 평균을 중복으로 붙일 때도 `transform()`이 아닌 일반적인 `mean()` 적용 후 `pd.merge()`를 사용할 수도 있을 것이다.


- 여기선 이 챕터의 함수를 활용하려고 위와 같이 풀어보았다.

## PIVOT TABLE

`pivot_table()`은 groupby 결과에 unstack을 자동 적용하여 2차원적인 형태로 변형한다.

- pivot_table(data, values=None, index=None, columns=None, aggfunc='mean', fill_value=None, margins=False, margins_name='All')

    - data: 분석할 데이터프레임 (메서드일 때는 필요하지 않음)

    - values: 분석할 데이터프레임에서 분석할 열

    - index: 행 인덱스로 들어갈 키 열 또는 키 열의 리스트

    - columns: 열 인덱스로 들어갈 키 열 또는 키 열의 리스트

    - aggfunc: 분석 메서드

    - fill_value: NaN 대체 값

    - margins: 모든 데이터를 분석한 결과를 오른쪽과 아래에 붙일지 여부

    - margins_name: 마진 열(행)의 이름


```python
df1
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>도시</th>
      <th>연도</th>
      <th>인구</th>
      <th>지역</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>서울</td>
      <td>2015</td>
      <td>9904312</td>
      <td>수도권</td>
    </tr>
    <tr>
      <th>1</th>
      <td>서울</td>
      <td>2010</td>
      <td>9631482</td>
      <td>수도권</td>
    </tr>
    <tr>
      <th>2</th>
      <td>서울</td>
      <td>2005</td>
      <td>9762546</td>
      <td>수도권</td>
    </tr>
    <tr>
      <th>3</th>
      <td>부산</td>
      <td>2015</td>
      <td>3448737</td>
      <td>경상권</td>
    </tr>
    <tr>
      <th>4</th>
      <td>부산</td>
      <td>2010</td>
      <td>3393191</td>
      <td>경상권</td>
    </tr>
    <tr>
      <th>5</th>
      <td>부산</td>
      <td>2005</td>
      <td>3512547</td>
      <td>경상권</td>
    </tr>
    <tr>
      <th>6</th>
      <td>인천</td>
      <td>2015</td>
      <td>2890451</td>
      <td>수도권</td>
    </tr>
    <tr>
      <th>7</th>
      <td>인천</td>
      <td>2010</td>
      <td>263203</td>
      <td>수도권</td>
    </tr>
  </tbody>
</table>
</div>




```python
df1.pivot_table("인구", "도시", "연도")
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>연도</th>
      <th>2005</th>
      <th>2010</th>
      <th>2015</th>
    </tr>
    <tr>
      <th>도시</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>부산</th>
      <td>3512547.0</td>
      <td>3393191.0</td>
      <td>3448737.0</td>
    </tr>
    <tr>
      <th>서울</th>
      <td>9762546.0</td>
      <td>9631482.0</td>
      <td>9904312.0</td>
    </tr>
    <tr>
      <th>인천</th>
      <td>NaN</td>
      <td>263203.0</td>
      <td>2890451.0</td>
    </tr>
  </tbody>
</table>
</div>



- 중복 값이 없기 때문에 `pivot()`과 같은 결과가 출력된다.


- `pivot()`은 행, 열, 값 순으로 입력하지만 `pivot_table()`은 값, 행, 열 순임을 기억하자.


```python
# 마진열 추가
df1.pivot_table("인구", "도시", "연도", margins = True, margins_name = "행 평균")
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>연도</th>
      <th>2005</th>
      <th>2010</th>
      <th>2015</th>
      <th>행 평균</th>
    </tr>
    <tr>
      <th>도시</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>부산</th>
      <td>3512547.0</td>
      <td>3393191.0</td>
      <td>3448737.0</td>
      <td>3.451492e+06</td>
    </tr>
    <tr>
      <th>서울</th>
      <td>9762546.0</td>
      <td>9631482.0</td>
      <td>9904312.0</td>
      <td>9.766113e+06</td>
    </tr>
    <tr>
      <th>인천</th>
      <td>NaN</td>
      <td>263203.0</td>
      <td>2890451.0</td>
      <td>1.576827e+06</td>
    </tr>
    <tr>
      <th>행 평균</th>
      <td>6637546.5</td>
      <td>4429292.0</td>
      <td>5414500.0</td>
      <td>5.350809e+06</td>
    </tr>
  </tbody>
</table>
</div>



- margins 옵션을 True로 설정하면 각 행, 열별 그룹 연산값이 추가된다.


- 위 예시에선 aggfunc 옵션이 디폴트가 mean이므로 각 행, 열별로 평균값이 추가된다.


```python
# 행 인덱스만 넣은 경우
df1.pivot_table("인구", index=["연도", "도시"])
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>인구</th>
    </tr>
    <tr>
      <th>연도</th>
      <th>도시</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">2005</th>
      <th>부산</th>
      <td>3512547</td>
    </tr>
    <tr>
      <th>서울</th>
      <td>9762546</td>
    </tr>
    <tr>
      <th rowspan="3" valign="top">2010</th>
      <th>부산</th>
      <td>3393191</td>
    </tr>
    <tr>
      <th>서울</th>
      <td>9631482</td>
    </tr>
    <tr>
      <th>인천</th>
      <td>263203</td>
    </tr>
    <tr>
      <th rowspan="3" valign="top">2015</th>
      <th>부산</th>
      <td>3448737</td>
    </tr>
    <tr>
      <th>서울</th>
      <td>9904312</td>
    </tr>
    <tr>
      <th>인천</th>
      <td>2890451</td>
    </tr>
  </tbody>
</table>
</div>



- 열 인덱스를 지정하지 않은 경우 `groupby()` 결과 형태로 출력된다.


```python
# tips 데이터
tips = sns.load_dataset("tips")

# 팁 비율 = 팁 금액 / 전체 금액
tips['tip_pct'] = tips['tip'] / tips['total_bill']

tips.tail()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>total_bill</th>
      <th>tip</th>
      <th>sex</th>
      <th>smoker</th>
      <th>day</th>
      <th>time</th>
      <th>size</th>
      <th>tip_pct</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>239</th>
      <td>29.03</td>
      <td>5.92</td>
      <td>Male</td>
      <td>No</td>
      <td>Sat</td>
      <td>Dinner</td>
      <td>3</td>
      <td>0.203927</td>
    </tr>
    <tr>
      <th>240</th>
      <td>27.18</td>
      <td>2.00</td>
      <td>Female</td>
      <td>Yes</td>
      <td>Sat</td>
      <td>Dinner</td>
      <td>2</td>
      <td>0.073584</td>
    </tr>
    <tr>
      <th>241</th>
      <td>22.67</td>
      <td>2.00</td>
      <td>Male</td>
      <td>Yes</td>
      <td>Sat</td>
      <td>Dinner</td>
      <td>2</td>
      <td>0.088222</td>
    </tr>
    <tr>
      <th>242</th>
      <td>17.82</td>
      <td>1.75</td>
      <td>Male</td>
      <td>No</td>
      <td>Sat</td>
      <td>Dinner</td>
      <td>2</td>
      <td>0.098204</td>
    </tr>
    <tr>
      <th>243</th>
      <td>18.78</td>
      <td>3.00</td>
      <td>Female</td>
      <td>No</td>
      <td>Thur</td>
      <td>Dinner</td>
      <td>2</td>
      <td>0.159744</td>
    </tr>
  </tbody>
</table>
</div>



- 이번엔 tips 데이터를 이용해서 여러 그룹별 연산을 시행해보자.


- tip_pct라는 팁 비율 열을 추가해주었다.


- 나는 함수가 어떤 기능인지를 확인하는 것에 초점을 두어서 뒤에 나올 그룹 연산 결과 해석은 거의 하지 않았다.


```python
# 기술 통계량 확인
tips.describe()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>total_bill</th>
      <th>tip</th>
      <th>size</th>
      <th>tip_pct</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>244.000000</td>
      <td>244.000000</td>
      <td>244.000000</td>
      <td>244.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>19.785943</td>
      <td>2.998279</td>
      <td>2.569672</td>
      <td>0.160803</td>
    </tr>
    <tr>
      <th>std</th>
      <td>8.902412</td>
      <td>1.383638</td>
      <td>0.951100</td>
      <td>0.061072</td>
    </tr>
    <tr>
      <th>min</th>
      <td>3.070000</td>
      <td>1.000000</td>
      <td>1.000000</td>
      <td>0.035638</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>13.347500</td>
      <td>2.000000</td>
      <td>2.000000</td>
      <td>0.129127</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>17.795000</td>
      <td>2.900000</td>
      <td>2.000000</td>
      <td>0.154770</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>24.127500</td>
      <td>3.562500</td>
      <td>3.000000</td>
      <td>0.191475</td>
    </tr>
    <tr>
      <th>max</th>
      <td>50.810000</td>
      <td>10.000000</td>
      <td>6.000000</td>
      <td>0.710345</td>
    </tr>
  </tbody>
</table>
</div>




```python
# 성별 갯수
tips.groupby("sex").count()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>total_bill</th>
      <th>tip</th>
      <th>smoker</th>
      <th>day</th>
      <th>time</th>
      <th>size</th>
      <th>tip_pct</th>
    </tr>
    <tr>
      <th>sex</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Male</th>
      <td>157</td>
      <td>157</td>
      <td>157</td>
      <td>157</td>
      <td>157</td>
      <td>157</td>
      <td>157</td>
    </tr>
    <tr>
      <th>Female</th>
      <td>87</td>
      <td>87</td>
      <td>87</td>
      <td>87</td>
      <td>87</td>
      <td>87</td>
      <td>87</td>
    </tr>
  </tbody>
</table>
</div>




```python
tips.groupby("sex").size()
```




    sex
    Male      157
    Female     87
    dtype: int64



- `size()`를 사용하면 `count()`와 달리 여러 변수로 갯수가 나타나지 않는다.


- 위 예시로 생각하면 남자/여자가 몇 명인지 확인하는데 굳이 여러 변수로 볼 필요가 없다.


- 다만 `size()`는 NaN을 포함해서 결과를 출력하므로 주의해야 한다.


```python
# 성별/흡연유무별 갯수
tips.groupby(["sex", "smoker"]).size()
```




    sex     smoker
    Male    Yes       60
            No        97
    Female  Yes       33
            No        54
    dtype: int64




```python
# 피봇테이블 형태로 위 셀에서 unstack을 한것에 마진이 추가되있음
tips.pivot_table("tip_pct", "sex", "smoker", aggfunc="count", margins=True)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>smoker</th>
      <th>Yes</th>
      <th>No</th>
      <th>All</th>
    </tr>
    <tr>
      <th>sex</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Male</th>
      <td>60</td>
      <td>97</td>
      <td>157</td>
    </tr>
    <tr>
      <th>Female</th>
      <td>33</td>
      <td>54</td>
      <td>87</td>
    </tr>
    <tr>
      <th>All</th>
      <td>93</td>
      <td>151</td>
      <td>244</td>
    </tr>
  </tbody>
</table>
</div>




```python
# 성별 팁 비율
tips.groupby("sex")[["tip_pct"]].mean()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>tip_pct</th>
    </tr>
    <tr>
      <th>sex</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Male</th>
      <td>0.157651</td>
    </tr>
    <tr>
      <th>Female</th>
      <td>0.166491</td>
    </tr>
  </tbody>
</table>
</div>




```python
# 성별 팁 비율 - 피봇 테이블 이용
tips.pivot_table("tip_pct", "sex")
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>tip_pct</th>
    </tr>
    <tr>
      <th>sex</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Male</th>
      <td>0.157651</td>
    </tr>
    <tr>
      <th>Female</th>
      <td>0.166491</td>
    </tr>
  </tbody>
</table>
</div>




```python
# 성별/흡연유무별 평균 팁 비율
tips.pivot_table("tip_pct", "sex", "smoker")
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>smoker</th>
      <th>Yes</th>
      <th>No</th>
    </tr>
    <tr>
      <th>sex</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Male</th>
      <td>0.152771</td>
      <td>0.160669</td>
    </tr>
    <tr>
      <th>Female</th>
      <td>0.182150</td>
      <td>0.156921</td>
    </tr>
  </tbody>
</table>
</div>




```python
tips.groupby(["sex", "smoker"])[["tip_pct"]].describe().T
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th>sex</th>
      <th colspan="2" halign="left">Male</th>
      <th colspan="2" halign="left">Female</th>
    </tr>
    <tr>
      <th></th>
      <th>smoker</th>
      <th>Yes</th>
      <th>No</th>
      <th>Yes</th>
      <th>No</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="8" valign="top">tip_pct</th>
      <th>count</th>
      <td>60.000000</td>
      <td>97.000000</td>
      <td>33.000000</td>
      <td>54.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>0.152771</td>
      <td>0.160669</td>
      <td>0.182150</td>
      <td>0.156921</td>
    </tr>
    <tr>
      <th>std</th>
      <td>0.090588</td>
      <td>0.041849</td>
      <td>0.071595</td>
      <td>0.036421</td>
    </tr>
    <tr>
      <th>min</th>
      <td>0.035638</td>
      <td>0.071804</td>
      <td>0.056433</td>
      <td>0.056797</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>0.101845</td>
      <td>0.131810</td>
      <td>0.152439</td>
      <td>0.139708</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>0.141015</td>
      <td>0.157604</td>
      <td>0.173913</td>
      <td>0.149691</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>0.191697</td>
      <td>0.186220</td>
      <td>0.198216</td>
      <td>0.181630</td>
    </tr>
    <tr>
      <th>max</th>
      <td>0.710345</td>
      <td>0.291990</td>
      <td>0.416667</td>
      <td>0.252672</td>
    </tr>
  </tbody>
</table>
</div>



## 연습문제 4.7.3

팁의 비율이 요일과 점심/저녁 여부, 인원수에 어떤 영향을 받는지 살펴본다.

어떤 요인이 가장 크게 작용하는지 판단할 수 있는 방법이 있는가?


```python
# 평균 팁 비율 기술 통계량
tips[["tip_pct"]].describe()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>tip_pct</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>244.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>0.160803</td>
    </tr>
    <tr>
      <th>std</th>
      <td>0.061072</td>
    </tr>
    <tr>
      <th>min</th>
      <td>0.035638</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>0.129127</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>0.154770</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>0.191475</td>
    </tr>
    <tr>
      <th>max</th>
      <td>0.710345</td>
    </tr>
  </tbody>
</table>
</div>




```python
# 요일별로 분석
tips.groupby("day")[["tip_pct"]].describe().T
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>day</th>
      <th>Thur</th>
      <th>Fri</th>
      <th>Sat</th>
      <th>Sun</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="8" valign="top">tip_pct</th>
      <th>count</th>
      <td>62.000000</td>
      <td>19.000000</td>
      <td>87.000000</td>
      <td>76.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>0.161276</td>
      <td>0.169913</td>
      <td>0.153152</td>
      <td>0.166897</td>
    </tr>
    <tr>
      <th>std</th>
      <td>0.038652</td>
      <td>0.047665</td>
      <td>0.051293</td>
      <td>0.084739</td>
    </tr>
    <tr>
      <th>min</th>
      <td>0.072961</td>
      <td>0.103555</td>
      <td>0.035638</td>
      <td>0.059447</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>0.138210</td>
      <td>0.133739</td>
      <td>0.123863</td>
      <td>0.119982</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>0.153846</td>
      <td>0.155625</td>
      <td>0.151832</td>
      <td>0.161103</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>0.192687</td>
      <td>0.196637</td>
      <td>0.188271</td>
      <td>0.187889</td>
    </tr>
    <tr>
      <th>max</th>
      <td>0.266312</td>
      <td>0.263480</td>
      <td>0.325733</td>
      <td>0.710345</td>
    </tr>
  </tbody>
</table>
</div>



- 금요일에 평균 팁 비율이 가장 높았으나 금요일 손님이 가장 적다.


```python
# 시간별로 분석
tips.groupby("time")[["tip_pct"]].describe().T
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>time</th>
      <th>Lunch</th>
      <th>Dinner</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="8" valign="top">tip_pct</th>
      <th>count</th>
      <td>68.000000</td>
      <td>176.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>0.164128</td>
      <td>0.159518</td>
    </tr>
    <tr>
      <th>std</th>
      <td>0.040242</td>
      <td>0.067477</td>
    </tr>
    <tr>
      <th>min</th>
      <td>0.072961</td>
      <td>0.035638</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>0.139147</td>
      <td>0.123192</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>0.154084</td>
      <td>0.155400</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>0.193917</td>
      <td>0.188209</td>
    </tr>
    <tr>
      <th>max</th>
      <td>0.266312</td>
      <td>0.710345</td>
    </tr>
  </tbody>
</table>
</div>



- 점심에 비해 저녁 손님이 더 많았고 평균 팁 비율은 점심 손님이 더 높다.


```python
# 인원수별로 분석
tips.groupby("size")[["tip_pct"]].describe().T
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>size</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
      <th>6</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="8" valign="top">tip_pct</th>
      <th>count</th>
      <td>4.000000</td>
      <td>156.000000</td>
      <td>38.000000</td>
      <td>37.000000</td>
      <td>5.000000</td>
      <td>4.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>0.217292</td>
      <td>0.165719</td>
      <td>0.152157</td>
      <td>0.145949</td>
      <td>0.141495</td>
      <td>0.156229</td>
    </tr>
    <tr>
      <th>std</th>
      <td>0.080342</td>
      <td>0.066848</td>
      <td>0.045459</td>
      <td>0.042395</td>
      <td>0.067733</td>
      <td>0.042153</td>
    </tr>
    <tr>
      <th>min</th>
      <td>0.137931</td>
      <td>0.035638</td>
      <td>0.056433</td>
      <td>0.077459</td>
      <td>0.065660</td>
      <td>0.103799</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>0.170779</td>
      <td>0.135223</td>
      <td>0.124758</td>
      <td>0.117750</td>
      <td>0.106572</td>
      <td>0.131654</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>0.202752</td>
      <td>0.156104</td>
      <td>0.159323</td>
      <td>0.146699</td>
      <td>0.121389</td>
      <td>0.162891</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>0.249265</td>
      <td>0.195036</td>
      <td>0.186135</td>
      <td>0.169797</td>
      <td>0.172194</td>
      <td>0.187466</td>
    </tr>
    <tr>
      <th>max</th>
      <td>0.325733</td>
      <td>0.710345</td>
      <td>0.230742</td>
      <td>0.280535</td>
      <td>0.241663</td>
      <td>0.195335</td>
    </tr>
  </tbody>
</table>
</div>



- 2인 손님이 가장 많고 평균 팁 비율도 가장 높다.


```python
# 점심시간 요일/인원수별 평균 팁 비율
temp = tips.pivot_table("tip_pct","day",["time","size"], fill_value = 0, margins= True)
temp["Lunch"]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>size</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
      <th>6</th>
    </tr>
    <tr>
      <th>day</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Thur</th>
      <td>0.181728</td>
      <td>0.164024</td>
      <td>0.144599</td>
      <td>0.145515</td>
      <td>0.121389</td>
      <td>0.173706</td>
    </tr>
    <tr>
      <th>Fri</th>
      <td>0.223776</td>
      <td>0.181969</td>
      <td>0.187735</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>Sat</th>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>Sun</th>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>All</th>
      <td>0.202752</td>
      <td>0.165750</td>
      <td>0.153226</td>
      <td>0.145515</td>
      <td>0.121389</td>
      <td>0.173706</td>
    </tr>
  </tbody>
</table>
</div>




```python
# 저녁시간 요일/인원수별 평균 팁 비율
temp["Dinner"]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>size</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
      <th>6</th>
    </tr>
    <tr>
      <th>day</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Thur</th>
      <td>0.000000</td>
      <td>0.159744</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>Fri</th>
      <td>0.000000</td>
      <td>0.162659</td>
      <td>0.000000</td>
      <td>0.117750</td>
      <td>0.000000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>Sat</th>
      <td>0.231832</td>
      <td>0.155289</td>
      <td>0.151439</td>
      <td>0.138289</td>
      <td>0.106572</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>Sun</th>
      <td>0.000000</td>
      <td>0.180870</td>
      <td>0.152662</td>
      <td>0.153168</td>
      <td>0.159839</td>
      <td>0.103799</td>
    </tr>
    <tr>
      <th>All</th>
      <td>0.231832</td>
      <td>0.165704</td>
      <td>0.151995</td>
      <td>0.146017</td>
      <td>0.146522</td>
      <td>0.103799</td>
    </tr>
  </tbody>
</table>
</div>



---


```python
# tip의 최대 - 최소
def peak_to_peak(x):
    return x.max() - x.min()


tips.groupby(["sex", "smoker"])[["tip"]].agg(peak_to_peak)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>tip</th>
    </tr>
    <tr>
      <th>sex</th>
      <th>smoker</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">Male</th>
      <th>Yes</th>
      <td>9.00</td>
    </tr>
    <tr>
      <th>No</th>
      <td>7.75</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Female</th>
      <th>Yes</th>
      <td>5.50</td>
    </tr>
    <tr>
      <th>No</th>
      <td>4.20</td>
    </tr>
  </tbody>
</table>
</div>



**여러 연산 동시에 수행시**


```python
tips.groupby(["sex", "smoker"])[["total_bill"]].agg(["mean", peak_to_peak])
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th colspan="2" halign="left">total_bill</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>mean</th>
      <th>peak_to_peak</th>
    </tr>
    <tr>
      <th>sex</th>
      <th>smoker</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">Male</th>
      <th>Yes</th>
      <td>22.284500</td>
      <td>43.56</td>
    </tr>
    <tr>
      <th>No</th>
      <td>19.791237</td>
      <td>40.82</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Female</th>
      <th>Yes</th>
      <td>17.977879</td>
      <td>41.23</td>
    </tr>
    <tr>
      <th>No</th>
      <td>18.105185</td>
      <td>28.58</td>
    </tr>
  </tbody>
</table>
</div>



- 여러 연산을 동시에 수행하고 싶을땐 리스트를 활용한다.

**열별로 다른 연산**


```python
tips.groupby(["sex", "smoker"]).agg({'tip_pct': 'count', 'total_bill': peak_to_peak})
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>tip_pct</th>
      <th>total_bill</th>
    </tr>
    <tr>
      <th>sex</th>
      <th>smoker</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">Male</th>
      <th>Yes</th>
      <td>60</td>
      <td>43.56</td>
    </tr>
    <tr>
      <th>No</th>
      <td>97</td>
      <td>40.82</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Female</th>
      <th>Yes</th>
      <td>33</td>
      <td>41.23</td>
    </tr>
    <tr>
      <th>No</th>
      <td>54</td>
      <td>28.58</td>
    </tr>
  </tbody>
</table>
</div>



- 만약 각 열별로 다른 연산을 하고 싶으면 dictionary를 활용한다.


```python
# 값2, 행2, 열1
tips.pivot_table(['tip_pct', 'size'], ['sex', 'day'], 'smoker')
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th colspan="2" halign="left">size</th>
      <th colspan="2" halign="left">tip_pct</th>
    </tr>
    <tr>
      <th></th>
      <th>smoker</th>
      <th>Yes</th>
      <th>No</th>
      <th>Yes</th>
      <th>No</th>
    </tr>
    <tr>
      <th>sex</th>
      <th>day</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="4" valign="top">Male</th>
      <th>Thur</th>
      <td>2.300000</td>
      <td>2.500000</td>
      <td>0.164417</td>
      <td>0.165706</td>
    </tr>
    <tr>
      <th>Fri</th>
      <td>2.125000</td>
      <td>2.000000</td>
      <td>0.144730</td>
      <td>0.138005</td>
    </tr>
    <tr>
      <th>Sat</th>
      <td>2.629630</td>
      <td>2.656250</td>
      <td>0.139067</td>
      <td>0.162132</td>
    </tr>
    <tr>
      <th>Sun</th>
      <td>2.600000</td>
      <td>2.883721</td>
      <td>0.173964</td>
      <td>0.158291</td>
    </tr>
    <tr>
      <th rowspan="4" valign="top">Female</th>
      <th>Thur</th>
      <td>2.428571</td>
      <td>2.480000</td>
      <td>0.163073</td>
      <td>0.155971</td>
    </tr>
    <tr>
      <th>Fri</th>
      <td>2.000000</td>
      <td>2.500000</td>
      <td>0.209129</td>
      <td>0.165296</td>
    </tr>
    <tr>
      <th>Sat</th>
      <td>2.200000</td>
      <td>2.307692</td>
      <td>0.163817</td>
      <td>0.147993</td>
    </tr>
    <tr>
      <th>Sun</th>
      <td>2.500000</td>
      <td>3.071429</td>
      <td>0.237075</td>
      <td>0.165710</td>
    </tr>
  </tbody>
</table>
</div>




```python
# 값1, 행3, 열1
tips.pivot_table('size', ['time', 'sex', 'smoker'], 'day',
                 aggfunc='sum', fill_value=0)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>day</th>
      <th>Thur</th>
      <th>Fri</th>
      <th>Sat</th>
      <th>Sun</th>
    </tr>
    <tr>
      <th>time</th>
      <th>sex</th>
      <th>smoker</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="4" valign="top">Lunch</th>
      <th rowspan="2" valign="top">Male</th>
      <th>Yes</th>
      <td>23</td>
      <td>5</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>No</th>
      <td>50</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Female</th>
      <th>Yes</th>
      <td>17</td>
      <td>6</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>No</th>
      <td>60</td>
      <td>3</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th rowspan="4" valign="top">Dinner</th>
      <th rowspan="2" valign="top">Male</th>
      <th>Yes</th>
      <td>0</td>
      <td>12</td>
      <td>71</td>
      <td>39</td>
    </tr>
    <tr>
      <th>No</th>
      <td>0</td>
      <td>4</td>
      <td>85</td>
      <td>124</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Female</th>
      <th>Yes</th>
      <td>0</td>
      <td>8</td>
      <td>33</td>
      <td>10</td>
    </tr>
    <tr>
      <th>No</th>
      <td>2</td>
      <td>2</td>
      <td>30</td>
      <td>43</td>
    </tr>
  </tbody>
</table>
</div>



## 연습문제 4.7.4

타이타닉 승객 데이터를 이용하여 다음 분석을 실시하라. 데이터는 다음과 같이 받을 수 있다.

`titanic = sns.load_dataset("titanic")`

1. qcut 명령으로 세 개의 나이 그룹을 만든다.


2. 성별, 선실, 나이 그룹에 의한 생존율을 데이터프레임으로 계산한다.

   행에는 성별 및 나이 그룹에 대한 다중 인덱스를 사용하고 열에는 선실 인덱스를 사용한다.
   
   생존률은 해당 그룹의 생존 인원수를 전체 인원수로 나눈 값이다.


3. 성별 및 선실에 의한 생존율을 피봇 데이터 형태로 만든다.


```python
titanic = sns.load_dataset("titanic")
titanic.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>survived</th>
      <th>pclass</th>
      <th>sex</th>
      <th>age</th>
      <th>sibsp</th>
      <th>parch</th>
      <th>fare</th>
      <th>embarked</th>
      <th>class</th>
      <th>who</th>
      <th>adult_male</th>
      <th>deck</th>
      <th>embark_town</th>
      <th>alive</th>
      <th>alone</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>3</td>
      <td>male</td>
      <td>22.0</td>
      <td>1</td>
      <td>0</td>
      <td>7.2500</td>
      <td>S</td>
      <td>Third</td>
      <td>man</td>
      <td>True</td>
      <td>NaN</td>
      <td>Southampton</td>
      <td>no</td>
      <td>False</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>1</td>
      <td>female</td>
      <td>38.0</td>
      <td>1</td>
      <td>0</td>
      <td>71.2833</td>
      <td>C</td>
      <td>First</td>
      <td>woman</td>
      <td>False</td>
      <td>C</td>
      <td>Cherbourg</td>
      <td>yes</td>
      <td>False</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1</td>
      <td>3</td>
      <td>female</td>
      <td>26.0</td>
      <td>0</td>
      <td>0</td>
      <td>7.9250</td>
      <td>S</td>
      <td>Third</td>
      <td>woman</td>
      <td>False</td>
      <td>NaN</td>
      <td>Southampton</td>
      <td>yes</td>
      <td>True</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1</td>
      <td>1</td>
      <td>female</td>
      <td>35.0</td>
      <td>1</td>
      <td>0</td>
      <td>53.1000</td>
      <td>S</td>
      <td>First</td>
      <td>woman</td>
      <td>False</td>
      <td>C</td>
      <td>Southampton</td>
      <td>yes</td>
      <td>False</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0</td>
      <td>3</td>
      <td>male</td>
      <td>35.0</td>
      <td>0</td>
      <td>0</td>
      <td>8.0500</td>
      <td>S</td>
      <td>Third</td>
      <td>man</td>
      <td>True</td>
      <td>NaN</td>
      <td>Southampton</td>
      <td>no</td>
      <td>True</td>
    </tr>
  </tbody>
</table>
</div>




```python
# age의 NaN이 포함되어 있음
titanic.count()
```




    survived       891
    pclass         891
    sex            891
    age            714
    sibsp          891
    parch          891
    fare           891
    embarked       889
    class          891
    who            891
    adult_male     891
    deck           203
    embark_town    889
    alive          891
    alone          891
    dtype: int64




```python
# NaN 값은 임의로 평균 age 값으로 대체
titanic["age"] = titanic["age"].fillna(titanic.age.mean())

# 1. 세 개의 나이그룹 생성
titanic["age_g"] = pd.qcut(titanic.age, 3, labels=["age1","age2","age3"])
titanic.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>survived</th>
      <th>pclass</th>
      <th>sex</th>
      <th>age</th>
      <th>sibsp</th>
      <th>parch</th>
      <th>fare</th>
      <th>embarked</th>
      <th>class</th>
      <th>who</th>
      <th>adult_male</th>
      <th>deck</th>
      <th>embark_town</th>
      <th>alive</th>
      <th>alone</th>
      <th>age_g</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>3</td>
      <td>male</td>
      <td>22.0</td>
      <td>1</td>
      <td>0</td>
      <td>7.2500</td>
      <td>S</td>
      <td>Third</td>
      <td>man</td>
      <td>True</td>
      <td>NaN</td>
      <td>Southampton</td>
      <td>no</td>
      <td>False</td>
      <td>age1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>1</td>
      <td>female</td>
      <td>38.0</td>
      <td>1</td>
      <td>0</td>
      <td>71.2833</td>
      <td>C</td>
      <td>First</td>
      <td>woman</td>
      <td>False</td>
      <td>C</td>
      <td>Cherbourg</td>
      <td>yes</td>
      <td>False</td>
      <td>age3</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1</td>
      <td>3</td>
      <td>female</td>
      <td>26.0</td>
      <td>0</td>
      <td>0</td>
      <td>7.9250</td>
      <td>S</td>
      <td>Third</td>
      <td>woman</td>
      <td>False</td>
      <td>NaN</td>
      <td>Southampton</td>
      <td>yes</td>
      <td>True</td>
      <td>age2</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1</td>
      <td>1</td>
      <td>female</td>
      <td>35.0</td>
      <td>1</td>
      <td>0</td>
      <td>53.1000</td>
      <td>S</td>
      <td>First</td>
      <td>woman</td>
      <td>False</td>
      <td>C</td>
      <td>Southampton</td>
      <td>yes</td>
      <td>False</td>
      <td>age3</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0</td>
      <td>3</td>
      <td>male</td>
      <td>35.0</td>
      <td>0</td>
      <td>0</td>
      <td>8.0500</td>
      <td>S</td>
      <td>Third</td>
      <td>man</td>
      <td>True</td>
      <td>NaN</td>
      <td>Southampton</td>
      <td>no</td>
      <td>True</td>
      <td>age3</td>
    </tr>
  </tbody>
</table>
</div>




```python
# 2. 성별, 선실, 나이 그룹에 의한 생존율을 데이터프레임으로 계산한다.
#    행에는 성별 및 나이 그룹에 대한 다중 인덱스를 사용하고 열에는 선실 인덱스를 사용한다.
#    생존률은 해당 그룹의 생존 인원수를 전체 인원수로 나눈 값이다.
def rate(x):
    return x.sum() / x.count()
    
titanic.groupby(["sex","age_g","class"])[["survived"]].agg(rate).unstack("class")


# 같은 결과 pivot_table
# titanic.pivot_table("survived", ["sex","age_g"], "class", aggfunc = rate)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th colspan="3" halign="left">survived</th>
    </tr>
    <tr>
      <th></th>
      <th>class</th>
      <th>First</th>
      <th>Second</th>
      <th>Third</th>
    </tr>
    <tr>
      <th>sex</th>
      <th>age_g</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="3" valign="top">female</th>
      <th>age1</th>
      <td>0.928571</td>
      <td>0.965517</td>
      <td>0.507692</td>
    </tr>
    <tr>
      <th>age2</th>
      <td>1.000000</td>
      <td>0.888889</td>
      <td>0.557377</td>
    </tr>
    <tr>
      <th>age3</th>
      <td>0.979167</td>
      <td>0.896552</td>
      <td>0.277778</td>
    </tr>
    <tr>
      <th rowspan="3" valign="top">male</th>
      <th>age1</th>
      <td>0.500000</td>
      <td>0.277778</td>
      <td>0.155039</td>
    </tr>
    <tr>
      <th>age2</th>
      <td>0.333333</td>
      <td>0.103448</td>
      <td>0.133803</td>
    </tr>
    <tr>
      <th>age3</th>
      <td>0.361111</td>
      <td>0.093023</td>
      <td>0.105263</td>
    </tr>
  </tbody>
</table>
</div>




```python
# 3 성별 및 선실에 의한 생존율을 피봇 데이터 형태로 만든다.
# 방법1
titanic.groupby(["sex","class"])[["survived"]].agg(rate).unstack("class")
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th colspan="3" halign="left">survived</th>
    </tr>
    <tr>
      <th>class</th>
      <th>First</th>
      <th>Second</th>
      <th>Third</th>
    </tr>
    <tr>
      <th>sex</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>female</th>
      <td>0.968085</td>
      <td>0.921053</td>
      <td>0.500000</td>
    </tr>
    <tr>
      <th>male</th>
      <td>0.368852</td>
      <td>0.157407</td>
      <td>0.135447</td>
    </tr>
  </tbody>
</table>
</div>




```python
# 방법2
# 1,0으로 이루어져 있으므로 그냥 mean을 하면 비율이 나옴
titanic.pivot_table("survived", "sex", "class")
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>class</th>
      <th>First</th>
      <th>Second</th>
      <th>Third</th>
    </tr>
    <tr>
      <th>sex</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>female</th>
      <td>0.968085</td>
      <td>0.921053</td>
      <td>0.500000</td>
    </tr>
    <tr>
      <th>male</th>
      <td>0.368852</td>
      <td>0.157407</td>
      <td>0.135447</td>
    </tr>
  </tbody>
</table>
</div>




```python
# 방법3
titanic.pivot_table("survived", "sex", "class", aggfunc = rate)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>class</th>
      <th>First</th>
      <th>Second</th>
      <th>Third</th>
    </tr>
    <tr>
      <th>sex</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>female</th>
      <td>0.968085</td>
      <td>0.921053</td>
      <td>0.500000</td>
    </tr>
    <tr>
      <th>male</th>
      <td>0.368852</td>
      <td>0.157407</td>
      <td>0.135447</td>
    </tr>
  </tbody>
</table>
</div>


