---
title: "[Python] 코딩 도장 - MVP를 찾아라"
excerpt: "코딩 도장 문제 풀어보기"
categories: 
  - codingdj
tags: 
    - Python
    - codingdj
# toc: TRUE
# toc_sticky: TRUE
use_math: TRUE
---

**코딩 도장** 사이트의 문제를 직접 풀어본 내용을 정리하여 올립니다.

[코딩 도장](https://codingdojang.com/)에서 여러 문제를 확인할 수 있습니다.

난이도 순으로 차근차근 풀어보려 합니다.

---

**[문제: MVP를 찾아라] - Lv.1**

**게임 개발**

당신이 참여했던 RPG게임이 대박이 나서 당신과 당신의 회사는 새로운 게임을 개발하기로 했다.

여러 날의 회의 끝에 새로운 게임의 장르는 AOS(MOBA)로 현재 자신들의 RPG게임의 IP를 사용하기로 했다.

그렇게 몇 날 며칠을 토론을 하며 게임의 틀이 잡혀졌고 각고의 노력 끝에 게임을 출시했다.

반응은 좋았으나 다른 게임들에 있는 MVP시스템이 있었으면 좋겠다는 요청이 들어와

빠져나가기 쉬운 유저들을 붙잡아두기 위해선 유저들의 요구를 하루빨리 들어주어야 했고

그 결과 실력이 가장 좋은 당신이 프로그래밍을 맡게되었다.

최대한 빠른 시일 내에, MVP를 출력하는 프로그램을 작성하시오.

---

**조건**

한 게임의 유저는 총 열명으로 두팀으로 나뉜다. (A1,A2...A5 와 B1,B2...B5로 구성된다.)

총 10줄에 걸쳐 각 유저들의 K/D/A를 입력받고 그에 따른 점수가 가장 높은 유저를 출력한다.

점수는 (K * 2 + A )/ (D+1) 이며 소수점 셋째 자리에서 반올림한다.

만약 같은 팀인데 점수가 똑같다면 점수가 똑같은 사람중에 어느 누구를 출력해도 상관이 없다.

오류가 있는 데이터는 존재하지 않는다. 즉, 데이터로는 더블킬인데 킬은 2킬보다 적은 경우는 주어지지 않는다.

데이터는 순서대로 주어지며 언제나 위쪽에 있는 데이터 5줄이 승자다.

---

**1차 업데이트**

이 게임도 성공을 하고 운영을 하던 도중 또 MVP시스템을 수정해달라는 글이 여럿 올라왔었다.

바로 연속으로 상대를 처치한 그 업적을 인정해주지 않는다는 것이었다.

그리고 자신의 팀이 이겼고 상대와 내가 점수가 똑같은데 왜 상대가 MVP냐는 글도 여럿 있었다.

그 글들을 취합해 당신은 또 다시 MVP시스템을 업그레이드 하게 되었다.

---

**업데이트 항목** 

연속으로 상대를 처치함에 따라 점수를 더하고 승리한 팀에게 모두 1점을 더하시오.

펜타킬 : P : 4

쿼드라킬 : Q : 3

트리플킬 : T : 2

더블킬 : D : 1

없음 : N : 0

---

```
입력

3/0/4 D
2/5/6 N
12/4/2 P
1/2/8 N
2/2/8 N
5/5/2 T
1/5/2 N
1/3/1 N
2/4/5 N
4/3/5 Q

출력

A1
```

A1 = 12.0, A2 = 2.67, A3 = 10.2, A4 = 4.33, A5 = 5.0,

B1 = 4.0, B2 = 0.67, B3 = 0.75, B4 = 1.8, B5 = 6.25

가장 점수가 큰 A1이 MVP이다.

출처: <https://codingdojang.com/scode/639?answer_mode=hide>

---

**[풀이]**


```python
data = ["3/0/4 D",
        "2/5/6 N",
        "12/4/2 P",
        "1/2/8 N",
        "2/2/8 N",
        "5/5/2 T",
        "1/5/2 N",
        "1/3/1 N",
        "2/4/5 N",
        "4/3/5 Q"]

def mvp(data):
    users = {}
    for i, user in enumerate(data):
        # K/D/A에 따른 점수
        lst = list(map(int, user[:-2].split("/")))
        kda = (lst[0]*2 + lst[2]) / (lst[1]+1)

        # 연속 킬에 따른 점수
        kill = user[-1]
        trans = kill.maketrans("PQTDN", "43210")
        kill = int(kill.translate(trans))

        # 승리 여부에 따른 점수 추가 최종 점수
        if i <= 4: 
            mvp_point = round(kda + kill + 1, 2)
            users[f"A{i+1}"] = mvp_point
        else: 
            mvp_point = round(kda + kill, 2)
            users[f"B{i-4}"] = mvp_point
            
    rank = sorted(users.items(), reverse=True, key=lambda x: x[1])
    
    return rank[0]

mvp(data)
```




    ('A1', 12.0)



우선 정확한 입력 형태가 뭔지 고민되었는데 나는 유저별로 스코어를 구분한 리스트를 입력하는 방법을 선택했다.

K/D/A는 `map()`과 `split()`을 이용해서 분리하여 쉽게 구하였고 연속킬에 대한 점수는 `translate()`를 사용하였다.

승리 여부에 따라 점수를 차등 부여하여 전체 유저 MVP 점수를 구한 후 유저와 MVP 점수를 출력하였다.

---

**[추천 풀이]**


```python
CK = ['N','D','T','Q','P']

data = list(input().split() for x in range(10))
for x in range(10):
    k = list(map(int,data[x][0].split('/')))
    data[x] = round((k[0]*2+k[2])/(k[1]+1),2) + (1 if x < 5 else 0) + CK.index(data[x][1])
n = data.index(max(data))
print('MVP :' + ['A','B'][0 if n < 5 else 1] + str(n+1))
```

    3/0/4 D
    2/5/6 N
    12/4/2 P
    1/2/8 N
    2/2/8 N
    5/5/2 T
    1/5/2 N
    1/3/1 N
    2/4/5 N
    4/3/5 Q
    MVP :A1
    

위 풀이보다 추천 수가 많은 풀이로 `pandas`를 사용하였는데 보니까 결과가 이상해서 그 다음 풀이를 가져왔다.

이 분은 나랑 비슷하지만 연속킬에 대한 점수를 추출할 떄 기존에 CK라는 리스트 생성 후 인덱스를 활용하였다.

그리고 지금은 결과가 A1 유저가 MVP인데 B5인 경우 이 분 코드론 B10이라고 나타날 듯 한데 자잘한거니..
